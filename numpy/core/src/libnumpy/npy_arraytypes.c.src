/* -*- c -*- */
#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "datetime.h"
#include "structmember.h"

#define _MULTIARRAYMODULE
#define NPY_NO_PREFIX
#include "numpy/arrayobject.h"
#include "numpy/arrayscalars.h"
#include "numpy/numpy_api.h"
#include "numpy/npy_object.h"

#include "npy_3kcompat.h"

#include "numpy/npy_math.h"


#define __ALIGNED(obj, sz) ((((size_t) obj) % (sz))==0)

#ifdef Npy_UNICODE_WIDE
#define NpyArray_UCS4_ISSPACE Npy_UNICODE_ISSPACE
#else
#define NpyArray_UCS4_ISSPACE(ch) Npy_STRING_ISSPACE((char)ch)
#endif


static Bool
Npy_STRING_ISSPACE(char ch);


#define NpyArray_TYPES       NPY_TYPES
#define NpyArray_BOOL        NPY_BOOL
#define NpyArray_BYTE        NPY_BYTE
#define NpyArray_UBYTE       NPY_UBYTE
#define NpyArray_SHORT       NPY_SHORT
#define NpyArray_USHORT      NPY_USHORT
#define NpyArray_INT         NPY_INT
#define NpyArray_UINT        NPY_UINT
#define NpyArray_LONG        NPY_LONG
#define NpyArray_ULONG       NPY_ULONG
#define NpyArray_LONGLONG    NPY_LONGLONG
#define NpyArray_ULONGLONG   NPY_ULONGLONG
#define NpyArray_FLOAT       NPY_FLOAT
#define NpyArray_DOUBLE      NPY_DOUBLE
#define NpyArray_LONGDOUBLE  NPY_LONGDOUBLE
#define NpyArray_CFLOAT      NPY_CFLOAT
#define NpyArray_CDOUBLE     NPY_CDOUBLE
#define NpyArray_CLONGDOUBLE NPY_CLONGDOUBLE
#define NpyArray_OBJECT      NPY_OBJECT
#define NpyArray_STRING      NPY_STRING
#define NpyArray_UNICODE     NPY_UNICODE
#define NpyArray_VOID        NPY_VOID
#define NpyArray_DATETIME    NPY_DATETIME
#define NpyArray_TIMEDELTA   NPY_TIMEDELTA
#define NpyArray_NTYPES      NPY_NTYPES
#define NpyArray_NOTYPE      NPY_NOTYPE
#define NpyArray_CHAR        NPY_CHAR
#define NpyArray_USERDEF     NPY_USERDEF
#define NpyArray_NUMUSERTYPES NPY_NUMUSERTYPES

#define NpyArray_VOID           NPY_VOID
#define NpyArray_TYPECHAR        NPY_TYPECHAR
#define NpyArray_BOOLLTR         NPY_BOOLLTR
#define NpyArray_BYTELTR         NPY_BYTELTR
#define NpyArray_UBYTELTR        NPY_UBYTELTR
#define NpyArray_SHORTLTR        NPY_SHORTLTR
#define NpyArray_USHORTLTR       NPY_USHORTLTR
#define NpyArray_INTLTR          NPY_INTLTR
#define NpyArray_UINTLTR         NPY_UINTLTR
#define NpyArray_LONGLTR         NPY_LONGLTR
#define NpyArray_ULONGLTR        NPY_ULONGLTR
#define NpyArray_LONGLONGLTR     NPY_LONGLONGLTR
#define NpyArray_ULONGLONGLTR    NPY_ULONGLONGLTR
#define NpyArray_FLOATLTR        NPY_FLOATLTR
#define NpyArray_DOUBLELTR       NPY_DOUBLELTR
#define NpyArray_LONGDOUBLELTR   NPY_LONGDOUBLELTR
#define NpyArray_CFLOATLTR       NPY_CFLOATLTR
#define NpyArray_CDOUBLELTR      NPY_CDOUBLELTR
#define NpyArray_CLONGDOUBLELTR  NPY_CLONGDOUBLELTR
#define NpyArray_OBJECTLTR       NPY_OBJECTLTR
#define NpyArray_STRINGLTR       NPY_STRINGLTR
#define NpyArray_STRINGLTR2      NPY_STRINGLTR2
#define NpyArray_UNICODELTR      NPY_UNICODELTR
#define NpyArray_VOIDLTR         NPY_VOIDLTR
#define NpyArray_DATETIMELTR     NPY_DATETIMELTR
#define NpyArray_TIMEDELTALTR    NPY_TIMEDELTALTR
#define NpyArray_CHARLTR         NPY_CHARLTR
#define NpyArray_INTPLTR         NPY_INTPLTR
#define NpyArray_UINTPLTR        NPY_UINTPLTR
#define NpyArray_GENBOOLLTR      NPY_GENBOOLLTR
#define NpyArray_SIGNEDLTR       NPY_SIGNEDLTR
#define NpyArray_UNSIGNEDLTR     NPY_UNSIGNEDLTR
#define NpyArray_FLOATINGLTR     NPY_FLOATINGLTR
#define NpyArray_COMPLEXLTR      NPY_COMPLEXLTR


/* TODO: Find a better way to handle getitem, setitem and other functions provided by the interface. */
/* From arraytypes.c.src */


extern Bool OBJECT_nonzero (void **ip, NpyArray *ap);


/**begin repeat
 * #name = number, integer, signedinteger, unsignedinteger, inexact,
 *         floating, complexfloating, flexible, character, timeinteger#
 * #NAME = Number, Integer, SignedInteger, UnsignedInteger, Inexact,
 *         Floating, ComplexFloating, Flexible, Character, TimeInteger#
 */
//NPY_NO_EXPORT NpyTypeObject Npy@NAME@ArrType_Type;
/**end repeat**/

    

/**begin repeat
 *
 * #TYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, LONG, UINT, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE#
 * #func1 = PyBool_FromLong, PyInt_FromLong*6, PyLong_FromUnsignedLong*2,
 *          PyLong_FromLongLong, PyLong_FromUnsignedLongLong,
 *          PyFloat_FromDouble*2#
 * #func2 = PyObject_IsTrue, MyPyLong_AsLong*6, MyPyLong_AsUnsignedLong*2,
 *          MyPyLong_AsLongLong, MyPyLong_AsUnsignedLongLong,
 *          MyPyFloat_AsDouble*2#
 * #type = Bool, byte, ubyte, short, ushort, int, long, uint, ulong,
 *         longlong, ulonglong, float, double#
 * #type1 = long*7, ulong*2, longlong, ulonglong, float, double#
 * #kind = Bool, Byte, UByte, Short, UShort, Int, Long, UInt, ULong,
 *         LongLong, ULongLong, Float, Double#
*/
extern PyObject *
@TYPE@_getitem(char *ip, NpyArray *ap);

extern int
@TYPE@_setitem(PyObject *op, char *ov, NpyArray *ap);

/**end repeat**/


/**begin repeat
 *
 * #TYPE = CFLOAT, CDOUBLE#
 * #type = float, double#
 */
extern PyObject *
@TYPE@_getitem(char *ip, NpyArray *ap);

/**end repeat**/



/**begin repeat
 *
 * #TYPE = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = float, double, longdouble#
 * #kind = CFloat, CDouble, CLongDouble#
 */
extern int
@TYPE@_setitem(PyObject *op, char *ov, NpyArray *ap);

/**end repeat**/

/*
 * These return array scalars which are different than other date-types.
 */

extern PyObject *
LONGDOUBLE_getitem(char *ip, NpyArray *ap);

extern int
LONGDOUBLE_setitem(PyObject *op, char *ov, NpyArray *ap);

extern PyObject *
CLONGDOUBLE_getitem(char *ip, NpyArray *ap);

/* UNICODE */
extern PyObject *
UNICODE_getitem(char *ip, NpyArray *ap);

extern int
UNICODE_setitem(PyObject *op, char *ov, NpyArray *ap);

extern PyObject *
STRING_getitem(char *ip, NpyArray *ap);

extern int
STRING_setitem(PyObject *op, char *ov, NpyArray *ap);

/* OBJECT */

extern PyObject *
OBJECT_getitem(char *ip, NpyArray *ap);

extern int
OBJECT_setitem(PyObject *op, char *ov, NpyArray *ap);

extern PyObject *
VOID_getitem(char *ip, NpyArray *ap);

extern int
VOID_setitem(PyObject *op, char *ip, NpyArray *ap);

extern PyObject *
DATETIME_getitem(char *ip, NpyArray *ap);

extern PyObject *
TIMEDELTA_getitem(char *ip, NpyArray *ap);

extern int
DATETIME_setitem(PyObject *op, char *ov, NpyArray *ap);

extern int
TIMEDELTA_setitem(PyObject *op, char *ov, NpyArray *ap);

    
/**begin repeat
 *
 * #FROMTYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *             LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *             CFLOAT, CDOUBLE, CLONGDOUBLE, STRING, UNICODE, VOID, OBJECT,
 *             DATETIME, TIMEDELTA#
 * #fromtype = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *             longlong, ulonglong, float, double, longdouble,
 *             cfloat, cdouble, clongdouble, char, char, char, PyObject *,
 *             datetime, timedelta#
 * #skip = 1*17, aip->descr->elsize*3, 1*3#
 */
extern void
@FROMTYPE@_to_OBJECT(@fromtype@ *ip, PyObject **op, intp n, NpyArray *aip,
                     NpyArray *NPY_UNUSED(aop));
/**end repeat**/


/**begin repeat
 *
 * #TOTYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *           LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *           CFLOAT, CDOUBLE, CLONGDOUBLE, STRING, UNICODE, VOID, DATETIME,
 *           TIMEDELTA#
 * #totype = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *           longlong, ulonglong, float, double, longdouble,
 *           cfloat, cdouble, clongdouble, char, char, char, datetime,
 *           timedelta#
 * #skip = 1*17, aop->descr->elsize*3, 1*2#
 */
extern void
OBJECT_to_@TOTYPE@(void **ip, @totype@ *op, npy_intp n,
                   NpyArray *aip, NpyArray *aop);
/**end repeat**/


/**begin repeat
 *
 * #from = STRING*22, UNICODE*22, VOID*22#
 * #fromtyp = char*66#
 * #to = (BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, CFLOAT, CDOUBLE, CLONGDOUBLE, STRING, UNICODE, VOID, DATETIME, TIMEDELTA)*3#
 * #totyp = (Bool, byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble, cfloat, cdouble, clongdouble, char, char, char, datetime, timedelta)*3#
 * #oskip = (1*17,aop->descr->elsize*3,1*2)*3#
 * #convert = 1*17, 0*3, 1*2, 1*17, 0*3, 1*2, 0*22#
 * #convstr = (Int*9, Long*2, Float*3, Complex*3, Tuple*3, Long*2)*3#
 */
extern void
@from@_to_@to@(@fromtyp@ *ip, @totyp@ *op, intp n, NpyArray *aip,
               NpyArray *aop);
/**end repeat**/


/**begin repeat
 *
 * #to = STRING*19, UNICODE*19, VOID*19#
 * #totyp = char*19, char*19, char*19#
 * #from = (BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE, DATETIME, TIMEDELTA)*3#
 * #fromtyp = (Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *            longlong, ulonglong, float, double, longdouble,
 *            cfloat, cdouble, clongdouble, datetime, timedelta)*3#
 */
extern void
@from@_to_@to@(@fromtyp@ *ip, @totyp@ *op, intp n, NpyArray *aip,
               NpyArray *aop);

/**end repeat**/


/*
 *****************************************************************************
 **                               SCAN                                      **
 *****************************************************************************
 */


/*
 * The first ignore argument is for backwards compatibility.
 * Should be removed when the API version is bumped up.
 */

/**begin repeat
 * #fname = SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG, ULONGLONG#
 * #type = short, ushort, int, uint, long, ulong, longlong, ulonglong#
 * #format = "hd", "hu", "d", "u", "ld", "lu", LONGLONG_FMT, ULONGLONG_FMT#
 */
extern int
@fname@_scan(FILE *fp, @type@ *ip, void *ignore, PyArray_Descr *NPY_UNUSED(ignored));
/**end repeat**/

/**begin repeat
 * #fname = FLOAT, DOUBLE, LONGDOUBLE#
 * #type = float, double, longdouble#
 */
extern int
@fname@_scan(FILE *fp, @type@ *ip, void *ignore, PyArray_Descr *ignored);
/**end repeat**/

/**begin repeat
 * #fname = BYTE, UBYTE#
 * #type = byte, ubyte#
 * #btype = int, uint#
 * #format = "d", "u"#
 */
extern int
@fname@_scan(FILE *fp, @type@ *ip, void *ignore, PyArray_Descr *ignore2);
/**end repeat**/

extern int
BOOL_scan(FILE *fp, Bool *ip, void *ignore, PyArray_Descr *ignore2);

/**begin repeat
 * #fname = CFLOAT, CDOUBLE, CLONGDOUBLE, OBJECT, STRING, UNICODE, VOID,
 *          DATETIME, TIMEDELTA#
 */
#define @fname@_scan NULL
/**end repeat**/


/**begin repeat
 * #fname = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG,
 *          ULONGLONG, DATETIME, TIMEDELTA#
 * #type = byte, ubyte, short, ushort, int, uint, long, ulong, longlong,
 *         ulonglong, datetime, timedelta#
 * #func = (l, ul)*5, l, l#
 * #btype = (long, ulong)*5, long, long#
 */
extern int
@fname@_fromstr(char *str, @type@ *ip, char **endptr, PyArray_Descr *ignore);
/**end repeat**/

/**begin repeat
 *
 * #fname=FLOAT,DOUBLE,LONGDOUBLE#
 * #type=float,double,longdouble#
 */
extern int
@fname@_fromstr(char *str, @type@ *ip, char **endptr, PyArray_Descr *ignore);
/**end repeat**/



/**begin repeat
 * #fname = BOOL, CFLOAT, CDOUBLE, CLONGDOUBLE, OBJECT, STRING, UNICODE, VOID#
 */
#define @fname@_fromstr NULL
/**end repeat**/



extern void
OBJECT_copyswapn (PyObject **dst, intp dstride, PyObject **src, intp sstride,
                  intp n, int swap, void *arr);

extern void
OBJECT_copyswap(PyObject **dst, PyObject **src, int swap, void *arr);


/* object type */

extern int
OBJECT_compare(PyObject **ip1, PyObject **ip2, NpyArray *ap);

extern int
OBJECT_argmax(PyObject **ip, intp n, intp *max_ind, NpyArray *aip);

extern void
OBJECT_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *ignore);



#define BOOL_fill NULL

/* this requires buffer to be filled with objects or NULL */
extern void
OBJECT_fill(PyObject **buffer, intp length, void *ignored);

extern void
OBJECT_fillwithscalar(PyObject **buffer, intp length, PyObject **value, void *ignored);



NPY_NO_EXPORT PyArray_Descr * PyArray_DescrNew \
       (PyArray_Descr *);



#define OBJECT_fastclip NULL


#define _NPY_UNUSEDBOOL  NPY_UNUSED
#define _NPY_UNUSEDBYTE  NPY_UNUSED
#define _NPY_UNUSEDUBYTE  NPY_UNUSED
#define _NPY_UNUSEDSHORT  NPY_UNUSED
#define _NPY_UNUSEDUSHORT  NPY_UNUSED
#define _NPY_UNUSEDINT  NPY_UNUSED
#define _NPY_UNUSEDUINT  NPY_UNUSED
#define _NPY_UNUSEDLONG  NPY_UNUSED
#define _NPY_UNUSEDULONG  NPY_UNUSED
#define _NPY_UNUSEDLONGLONG  NPY_UNUSED
#define _NPY_UNUSEDULONGLONG  NPY_UNUSED
#define _NPY_UNUSEDFLOAT  NPY_UNUSED
#define _NPY_UNUSEDDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDLONGDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDCFLOAT  NPY_UNUSED
#define _NPY_UNUSEDCDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDCLONGDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDDATETIME  NPY_UNUSED
#define _NPY_UNUSEDTIMEDELTA  NPY_UNUSED
#define _NPY_UNUSEDSTRING
#define _NPY_UNUSEDVOID
#define _NPY_UNUSEDUNICODE



/*
 *****************************************************************************
 **                       TYPE TO TYPE CONVERSIONS                          **
 *****************************************************************************
 */


/* Assumes contiguous, and aligned, from and to */


/**begin repeat
 *
 * #TOTYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *           LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, DATETIME,
 *           TIMEDELTA#
 * #totype = byte, ubyte, short, ushort, int, uint, long, ulong,
 *           longlong, ulonglong, float, double, longdouble, datetime,
 *           timedelta#
*/

/**begin repeat1
 *
 * #FROMTYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *             LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, DATETIME,
 *             TIMEDELTA#
 * #fromtype = byte, ubyte, short, ushort, int, uint, long, ulong,
 *             longlong, ulonglong, float, double, longdouble, datetime,
 *             timedelta#
 */
static void
@FROMTYPE@_to_@TOTYPE@(@fromtype@ *ip, @totype@ *op, intp n,
               NpyArray *NPY_UNUSED(aip), NpyArray *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (@totype@)*ip++;
    }
}
/**end repeat1**/

/**begin repeat1
 *
 * #FROMTYPE = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #fromtype = float, double, longdouble#
 */
static void
@FROMTYPE@_to_@TOTYPE@(@fromtype@ *ip, @totype@ *op, intp n,
               NpyArray *NPY_UNUSED(aip), NpyArray *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (@totype@)*ip;
        ip += 2;
    }
}
/**end repeat1**/

/**end repeat**/


/**begin repeat
 *
 * #FROMTYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *             LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, DATETIME,
 *             TIMEDELTA#
 * #fromtype = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *             longlong, ulonglong, float, double, longdouble, datetime,
 *             timedelta#
*/
static void
@FROMTYPE@_to_BOOL(@fromtype@ *ip, Bool *op, intp n,
               NpyArray *NPY_UNUSED(aip), NpyArray *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}
/**end repeat**/

/**begin repeat
 *
 * #FROMTYPE = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #fromtype = cfloat, cdouble, clongdouble#
*/
static void
@FROMTYPE@_to_BOOL(@fromtype@ *ip, Bool *op, intp n,
               NpyArray *NPY_UNUSED(aip), NpyArray *NPY_UNUSED(aop))
{
    while (n--) {
        *op = (Bool)(((*ip).real != FALSE) || ((*ip).imag != FALSE));
        op++;
        ip++;
    }
}
/**end repeat**/

/**begin repeat
 * #TOTYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *           LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, DATETIME,
 *           TIMEDELTA#
 * #totype = byte, ubyte, short, ushort, int, uint, long, ulong,
 *           longlong, ulonglong, float, double, longdouble, datetime,
 *           timedelta#
*/
static void
BOOL_to_@TOTYPE@(Bool *ip, @totype@ *op, intp n,
             NpyArray *NPY_UNUSED(aip), NpyArray *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (@totype@)(*ip++ != FALSE);
    }
}
/**end repeat**/

/**begin repeat
 *
 * #TOTYPE = CFLOAT,CDOUBLE,CLONGDOUBLE#
 * #totype = float, double, longdouble#
 */

/**begin repeat1
 * #FROMTYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *             LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, DATETIME,
 *             TIMEDELTA#
 * #fromtype = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *             longlong, ulonglong, float, double, longdouble, datetime,
 *             timedelta#
 */
static void
@FROMTYPE@_to_@TOTYPE@(@fromtype@ *ip, @totype@ *op, intp n,
               NpyArray *NPY_UNUSED(aip), NpyArray *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (@totype@)*ip++;
        *op++ = 0.0;
    }

}
/**end repeat1**/
/**end repeat**/

/**begin repeat
 *
 * #TOTYPE = CFLOAT,CDOUBLE,CLONGDOUBLE#
 * #totype = float, double, longdouble#
 */

/**begin repeat1
 * #FROMTYPE = CFLOAT,CDOUBLE,CLONGDOUBLE#
 * #fromtype = float, double, longdouble#
 */
static void
@FROMTYPE@_to_@TOTYPE@(@fromtype@ *ip, @totype@ *op, intp n,
               NpyArray *NPY_UNUSED(aip), NpyArray *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (@totype@)*ip++;
    }
}

/**end repeat1**/
/**end repeat**/


/*
 *****************************************************************************
 **                            COPYSWAPN                                    **
 *****************************************************************************
 */


/**begin repeat
 *
 * #fname = SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG, ULONGLONG, FLOAT,
 *          DOUBLE, LONGDOUBLE, DATETIME, TIMEDELTA#
 * #fsize = SHORT, SHORT, INT, INT, LONG, LONG, LONGLONG, LONGLONG, FLOAT,
 *          DOUBLE, LONGDOUBLE, DATETIME, TIMEDELTA#
 * #type = short, ushort, int, uint, long, ulong, longlong, ulonglong, float,
 *         double, longdouble, datetime, timedelta#
 */
static void
@fname@_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(@type@) && dstride == sizeof(@type@)) {
            memcpy(dst, src, n*sizeof(@type@));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(@type@));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(@type@));
    }
}

static void
@fname@_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(@type@));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_@fsize@ == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_@fsize@ == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_@fsize@ == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_@fsize@ == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_@fsize@ == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_@fsize@ == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_@fsize@-1);
            nn = SIZEOF_@fsize@ / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}

/**end repeat**/

/**begin repeat
 *
 * #fname = BOOL, BYTE, UBYTE#
 * #type = Bool, byte, ubyte#
 */
static void
@fname@_copyswapn (void *dst, intp dstride, void *src, intp sstride, intp n,
                   int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(@type@) && dstride == sizeof(@type@)) {
            memcpy(dst, src, n*sizeof(@type@));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(@type@));
        }
    }
    /* ignore swap */
}

static void
@fname@_copyswap (void *dst, void *src, int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(@type@));
    }
    /* ignore swap */
}

/**end repeat**/



/**begin repeat
 *
 * #fname = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = cfloat,  cdouble,  clongdouble#
 * #fsize = FLOAT, DOUBLE, LONGDOUBLE#
*/
static void
@fname@_copyswapn (void *dst, intp dstride, void *src, intp sstride, intp n,
                   int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        if (sstride == sizeof(@type@) && dstride == sizeof(@type@)) {
            memcpy(dst, src, n*sizeof(@type@));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride, n,
                    sizeof(@type@));
        }
    }

    if (swap) {
        _strided_byte_swap(dst, dstride, n, SIZEOF_@fsize@);
        _strided_byte_swap(((char *)dst + SIZEOF_@fsize@), dstride,
                n, SIZEOF_@fsize@);
    }
}

static void
@fname@_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) /* copy first if needed */
        memcpy(dst, src, sizeof(@type@));

    if (swap) {
        char *a, *b, c;
        a = (char *)dst;
#if SIZEOF_@fsize@ == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 2;
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_@fsize@ == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 4;
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_@fsize@ == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 5;
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_@fsize@ == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 6;
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_@fsize@ == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 8;
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_@fsize@ - 1);
            nn = SIZEOF_@fsize@ / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
            a += nn / 2;
            b = a + (SIZEOF_@fsize@ - 1);
            nn = SIZEOF_@fsize@ / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}

/**end repeat**/


/* ignore swap */
static void
STRING_copyswapn (char *dst, intp dstride, char *src, intp sstride,
                  intp n, int NPY_UNUSED(swap), NpyArray *arr)
{
    if (src != NULL && arr != NULL) {
        int itemsize = arr->descr->elsize;

        if (dstride == itemsize && sstride == itemsize) {
            memcpy(dst, src, itemsize * n);
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride, n,
                    itemsize);
        }
    }
    return;
}

/* */
static void
VOID_copyswapn (char *dst, intp dstride, char *src, intp sstride,
                intp n, int swap, NpyArray *arr)
{
    if (arr == NULL) {
        return;
    }
    if (NpyArray_HASFIELDS(arr)) {
        const char *key;
        NpyArray_Descr *descr;
        NpyArray_DescrField *value;
        NpyDict_Iter pos;

        descr = arr->descr;
        NpyDict_IterInit(&pos);
        while (NpyDict_IterNext(descr->fields, &pos, (void **)&key, (void **)&value)) {
            if (NULL != value->title && !strcmp(value->title, key)) {
                continue;
            }
            arr->descr = value->descr;
            value->descr->f->copyswapn(dst + value->offset, dstride,
                    (src != NULL ? src + value->offset : NULL),
                    sstride, n, swap, arr);
        }
        arr->descr = descr;
        return;
    }
    if (swap && arr->descr->subarray != NULL) {
        NpyArray_Descr *descr, *new;
        npy_intp num;
        npy_intp i;
        int subitemsize;
        char *dstptr, *srcptr;

        descr = arr->descr;
        new = descr->subarray->base;
        arr->descr = new;
        dstptr = dst;
        srcptr = src;
        subitemsize = new->elsize;
        num = descr->elsize / subitemsize;
        for (i = 0; i < n; i++) {
            new->f->copyswapn(dstptr, subitemsize, srcptr,
                    subitemsize, num, swap, arr);
            dstptr += dstride;
            if (srcptr) {
                srcptr += sstride;
            }
        }
        arr->descr = descr;
        return;
    }
    if (src != NULL) {
        memcpy(dst, src, arr->descr->elsize * n);
    }
    return;
}

static void
VOID_copyswap (char *dst, char *src, int swap, NpyArray *arr)
{
    if (arr == NULL) {
        return;
    }
    if (NpyArray_HASFIELDS(arr)) {
        const char *key;
        NpyArray_Descr *descr;
        NpyArray_DescrField *value;
        NpyDict_Iter pos;

        descr = arr->descr;
        NpyDict_IterInit(&pos);
        while (NpyDict_IterNext(descr->fields, &pos, (void **)&key, (void **)&value)) {
            if (NULL != value->title && !strcmp(value->title, key)) {
                continue;
            }
            arr->descr = value->descr;
            value->descr->f->copyswap(dst + value->offset,
                    (src != NULL ? src + value->offset : NULL),
                    swap, arr);
        }
        arr->descr = descr;
        return;
    }
    if (swap && arr->descr->subarray != NULL) {
        NpyArray_Descr *descr, *new;
        npy_intp num;
        int itemsize;

        descr = arr->descr;
        new = descr->subarray->base;
        arr->descr = new;
        itemsize = new->elsize;
        num = descr->elsize / itemsize;
        new->f->copyswapn(dst, itemsize, src,
                itemsize, num, swap, arr);
        arr->descr = descr;
        return;
    }
    if (src != NULL) {
        memcpy(dst, src, arr->descr->elsize);
    }
    return;
}


static void
UNICODE_copyswapn (char *dst, intp dstride, char *src, intp sstride,
                   intp n, int swap, NpyArray *arr)
{
    int itemsize;

    if (arr == NULL) {
        return;
    }
    itemsize = arr->descr->elsize;
    if (src != NULL) {
        if (dstride == itemsize && sstride == itemsize) {
            memcpy(dst, src, n * itemsize);
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src,
                    sstride, n, itemsize);
        }
    }

    n *= itemsize;
    if (swap) {
        char *a, *b, c;

        /* n is the number of unicode characters to swap */
        n >>= 2;
        for (a = (char *)dst; n > 0; n--) {
            b = a + 3;
            c = *a;
            *a++ = *b;
            *b-- = c;
            c = *a;
            *a++ = *b;
            *b-- = c;
            a += 2;
        }
    }
}


static void
STRING_copyswap(char *dst, char *src, int NPY_UNUSED(swap), NpyArray *arr)
{
    if (src != NULL && arr != NULL) {
        memcpy(dst, src, arr->descr->elsize);
    }
}

static void
UNICODE_copyswap (char *dst, char *src, int swap, NpyArray *arr)
{
    int itemsize;

    if (arr == NULL) {
        return;
    }
    itemsize = arr->descr->elsize;
    if (src != NULL) {
        memcpy(dst, src, itemsize);
    }

    if (swap) {
        char *a, *b, c;
        itemsize >>= 2;
        for (a = (char *)dst; itemsize>0; itemsize--) {
            b = a + 3;
            c = *a;
            *a++ = *b;
            *b-- = c;
            c = *a;
            *a++ = *b;
            *b-- = c;
            a += 2;
        }
    }
}



/*
 *****************************************************************************
 **                                 NONZERO                                 **
 *****************************************************************************
 */

/**begin repeat
 *
 * #fname = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *          LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *          DATETIME, TIMEDELTA#
 * #type = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, float, double, longdouble,
 *         datetime, timedelta#
 */
static Bool
@fname@_nonzero (char *ip, NpyArray *ap)
{
    if (ap == NULL || NpyArray_ISBEHAVED_RO(ap)) {
        @type@ *ptmp = (@type@ *)ip;
        return (Bool) (*ptmp != 0);
    }
    else {
        /*
         * don't worry about swap, since we are just testing
         * whether or not equal to 0
         */
        @type@ tmp;
        memcpy(&tmp, ip, sizeof(@type@));
        return (Bool) (tmp != 0);
    }
}
/**end repeat**/

/**begin repeat
 *
 * #fname=CFLOAT,CDOUBLE,CLONGDOUBLE#
 * #type=cfloat, cdouble, clongdouble#
 */
static Bool
@fname@_nonzero (char *ip, NpyArray *ap)
{
    if (ap == NULL || NpyArray_ISBEHAVED_RO(ap)) {
        @type@ *ptmp = (@type@ *)ip;
        return (Bool) ((ptmp->real != 0) || (ptmp->imag != 0));
    }
    else {
        /*
         * don't worry about swap, since we are just testing
         * whether or not equal to 0
         */
        @type@ tmp;
        memcpy(&tmp, ip, sizeof(@type@));
        return (Bool) ((tmp.real != 0) || (tmp.imag != 0));
    }
}
/**end repeat**/


#define WHITESPACE " \t\n\r\v\f"
#define WHITELEN 6

static Bool
Npy_STRING_ISSPACE(char ch)
{
    char white[] = WHITESPACE;
    int j;
    Bool space = FALSE;

    for (j = 0; j < WHITELEN; j++) {
        if (ch == white[j]) {
            space = TRUE;
            break;
        }
    }
    return space;
}

static Bool
STRING_nonzero (char *ip, NpyArray *ap)
{
    int len = ap->descr->elsize;
    int i;
    Bool nonz = FALSE;

    for (i = 0; i < len; i++) {
        if (!Npy_STRING_ISSPACE(*ip)) {
            nonz = TRUE;
            break;
        }
        ip++;
    }
    return nonz;
}


static Bool
UNICODE_nonzero (npy_ucs4 *ip, NpyArray *ap)
{
    int len = ap->descr->elsize >> 2;
    int i;
    Bool nonz = FALSE;
    char *buffer = NULL;

    if ((!NpyArray_ISNOTSWAPPED(ap)) || (!NpyArray_ISALIGNED(ap))) {
        buffer = NpyArray_malloc(ap->descr->elsize);
        if (buffer == NULL) {
            return nonz;
        }
        memcpy(buffer, ip, ap->descr->elsize);
        if (!NpyArray_ISNOTSWAPPED(ap)) {
            byte_swap_vector(buffer, len, 4);
        }
        ip = (npy_ucs4 *)buffer;
    }

    for (i = 0; i < len; i++) {
        if (!NpyArray_UCS4_ISSPACE(*ip)) {
            nonz = TRUE;
            break;
        }
        ip++;
    }
    NpyArray_free(buffer);
    return nonz;
}


/* TODO: Dead code? Also in arraytypes.c.src */
#if 0
Bool
OBJECT_nonzero (void **ip, NpyArray *ap)
{

    if (NpyArray_ISALIGNED(ap)) {
        if (*ip == NULL) {
            return FALSE;
        }
        return (Bool) PyObject_IsTrue(*(PyObject **)ip);
    }
    else {
        PyObject *obj;
        NPY_COPY_PYOBJECT_PTR(&obj, (PyObject **)ip);
        if (obj == NULL) {
            return FALSE;
        }
        return (Bool) PyObject_IsTrue(obj);
    }
}

#endif

/*
 * if we have fields, then nonzero only if all sub-fields are nonzero.
 */
static Bool
VOID_nonzero (char *ip, NpyArray *ap)
{
    int i;
    int len;
    Bool nonz = FALSE;

    if (NpyArray_HASFIELDS(ap)) {
        NpyArray_Descr *descr, *new;
        const char *key;
        NpyArray_DescrField *value;
        int savedflags;
        NpyDict_Iter pos;

        descr = ap->descr;
        savedflags = ap->flags;
        NpyDict_IterInit(&pos);
        while (NpyDict_IterNext(descr->fields, &pos, (void **)&key, (void **)&value)) {
            if (NULL != value->title && !strcmp(value->title, key)) {
                continue;
            }
            new = value->descr;
            ap->descr = new;
            ap->flags = savedflags;
            if ((new->alignment > 1) && !__ALIGNED(ip + value->offset, new->alignment)) {
                ap->flags &= ~ALIGNED;
            }
            else {
                ap->flags |= ALIGNED;
            }
            if (new->f->nonzero(ip + value->offset, ap)) {
                nonz = TRUE;
                break;
            }
        }
        ap->descr = descr;
        ap->flags = savedflags;
        return nonz;
    }
    len = ap->descr->elsize;
    for (i = 0; i < len; i++) {
        if (*ip != '\0') {
            nonz = TRUE;
            break;
        }
        ip++;
    }
    return nonz;
}

#undef __ALIGNED


/*
 *****************************************************************************
 **                                 COMPARE                                 **
 *****************************************************************************
 */


/* boolean type */

static int
BOOL_compare(Bool *ip1, Bool *ip2, NpyArray *NPY_UNUSED(ap))
{
    return (*ip1 ? (*ip2 ? 0 : 1) : (*ip2 ? -1 : 0));
}


/* integer types */

/**begin repeat
 * #TYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, DATETIME, TIMEDELTA#
 * #type = byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, datetime, timedelta#
 */

static int
@TYPE@_compare (@type@ *pa, @type@ *pb, NpyArray *NPY_UNUSED(ap))
{
    const @type@ a = *pa;
    const @type@ b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}

/**end repeat**/


/* float types */

/*
 * The real/complex comparison functions are compatible with the new sort
 * order for nans introduced in numpy 1.4.0. All nan values now compare
 * larger than non-nan values and are sorted to the end. The comparison
 * order is:
 *
 *      Real: [R, nan]
 *      Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
 *
 *  where complex values with the same nan placements are sorted according
 *  to the non-nan part if it exists. If both the real and imaginary parts
 *  of complex types are non-nan the order is the same as the real parts
 *  unless they happen to be equal, in which case the order is that of the
 *  imaginary parts.
 */

/**begin repeat
 *
 * #TYPE = FLOAT, DOUBLE, LONGDOUBLE#
 * #type = float, double, longdouble#
 */

#define LT(a,b) ((a) < (b) || ((b) != (b) && (a) ==(a)))

static int
@TYPE@_compare(@type@ *pa, @type@ *pb)
{
    const @type@ a = *pa;
    const @type@ b = *pb;
    int ret;

    if (LT(a,b)) {
        ret = -1;
    }
    else if (LT(b,a)) {
        ret = 1;
    }
    else {
        ret = 0;
    }
    return ret;
}


static int
C@TYPE@_compare(@type@ *pa, @type@ *pb)
{
    const @type@ ar = pa[0];
    const @type@ ai = pa[1];
    const @type@ br = pb[0];
    const @type@ bi = pb[1];
    int ret;

    if (ar < br) {
        if (ai == ai || bi != bi) {
            ret = -1;
        }
        else {
            ret = 1;
        }
    }
    else if (br < ar) {
        if (bi == bi || ai != ai) {
            ret = 1;
        }
        else {
            ret = -1;
        }
    }
    else if (ar == br || (ar != ar && br != br)) {
        if (LT(ai,bi)) {
            ret = -1;
        }
        else if (LT(bi,ai)) {
            ret = 1;
        }
        else {
            ret = 0;
        }
    }
    else if (ar == ar) {
        ret = -1;
    }
    else {
        ret = 1;
    }

    return ret;
}

#undef LT

/**end repeat**/


/* string type */

static int
STRING_compare(char *ip1, char *ip2, NpyArray *ap)
{
    const unsigned char *c1 = (unsigned char *)ip1;
    const unsigned char *c2 = (unsigned char *)ip2;
    const size_t len = ap->descr->elsize;
    size_t i;

    for(i = 0; i < len; ++i) {
        if (c1[i] != c2[i]) {
            return (c1[i] > c2[i]) ? 1 : -1;
        }
    }
    return 0;
}


/* unicode type */

static int
UNICODE_compare(npy_ucs4 *ip1, npy_ucs4 *ip2,
                NpyArray *ap)
{
    int itemsize = ap->descr->elsize/sizeof(PyArray_UCS4);

    if (itemsize < 0) {
        return 0;
    }
    while (itemsize-- > 0) {
        PyArray_UCS4 c1 = *ip1++;
        PyArray_UCS4 c2 = *ip2++;
        if (c1 != c2) {
            return (c1 < c2) ? -1 : 1;
        }
    }
    return 0;
}


/* void type */

/*
 * If fields are defined, then compare on first field and if equal
 * compare on second field.  Continue until done or comparison results
 * in not_equal.
 *
 * Must align data passed on to sub-comparisons.
 * Also must swap data based on to sub-comparisons.
 */
static int
VOID_compare(char *ip1, char *ip2, NpyArray *ap)
{
    NpyArray_Descr *descr, *new;
    char **names;
    NpyArray_DescrField *value;
    char *nip1, *nip2;
    int i, offset, res = 0, swap=0;

    if (!NpyArray_HASFIELDS(ap)) {
        return STRING_compare(ip1, ip2, ap);
    }
    descr = ap->descr;
    /*
     * Compare on the first-field.  If equal, then
     * compare on the second-field, etc.
     */
    names = descr->names;
    for (i = 0; NULL != names[i]; i++) {
        value = NpyDict_Get(descr->fields, names[i]);
        new = value->descr;
        offset = value->offset;
        
        ap->descr = new;
        swap = NpyArray_ISBYTESWAPPED(ap);
        nip1 = ip1+offset;
        nip2 = ip2+offset;
        if ((swap) || (new->alignment > 1)) {
            if ((swap) || (((intp)(nip1) % new->alignment) != 0)) {
                /* create buffer and copy */
                nip1 = NpyArray_malloc(new->elsize);
                if (nip1 == NULL) {
                    goto finish;
                }
                memcpy(nip1, ip1+offset, new->elsize);
                if (swap)
                    new->f->copyswap(nip1, NULL, swap, ap);
            }
            if ((swap) || (((intp)(nip2) % new->alignment) != 0)) {
                /* copy data to a buffer */
                nip2 = NpyArray_malloc(new->elsize);
                if (nip2 == NULL) {
                    if (nip1 != ip1+offset) {
                        NpyArray_free(nip1);
                    }
                    goto finish;
                }
                memcpy(nip2, ip2+offset, new->elsize);
                if (swap)
                    new->f->copyswap(nip2, NULL, swap, ap);
            }
        }
        res = new->f->compare(nip1, nip2, ap);
        if ((swap) || (new->alignment > 1)) {
            if (nip1 != ip1+offset) {
                NpyArray_free(nip1);
            }
            if (nip2 != ip2+offset) {
                NpyArray_free(nip2);
            }
        }
        if (res != 0) {
            break;
        }
    }

finish:
    ap->descr = descr;
    return res;
}


/*
 *****************************************************************************
 **                                 ARGFUNC                                 **
 *****************************************************************************
 */


/**begin repeat
 *
 * #fname = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *          LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *          CFLOAT, CDOUBLE, CLONGDOUBLE, DATETIME, TIMEDELTA#
 * #type = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, float, double, longdouble,
 *         float, double, longdouble, datetime, timedelta#
 * #incr = ip++*14, ip+=2*3, ip++*2#
 */
static int
@fname@_argmax(@type@ *ip, intp n, intp *max_ind, NpyArray *NPY_UNUSED(aip))
{
    intp i;
    @type@ mp = *ip;

    *max_ind = 0;
    for (i = 1; i < n; i++) {
        @incr@;
        if (*ip > mp) {
            mp = *ip;
            *max_ind = i;
        }
    }
    return 0;
}

/**end repeat**/


/**begin repeat
 *
 * #fname = STRING, UNICODE#
 * #type = char, PyArray_UCS4#
 */
static int
@fname@_argmax(@type@ *ip, intp n, intp *max_ind, NpyArray *aip)
{
    intp i;
    int elsize = aip->descr->elsize;
    @type@ *mp = (@type@ *)NpyArray_malloc(elsize);

    if (mp==NULL) return 0;
    memcpy(mp, ip, elsize);
    *max_ind = 0;
    for(i=1; i<n; i++) {
        ip += elsize/sizeof(@type@);
        if (@fname@_compare(ip,mp,aip) > 0) {
            memcpy(mp, ip, elsize);
            *max_ind=i;
        }
    }
    NpyArray_free(mp);
    return 0;
}

/**end repeat**/

#define VOID_argmax NULL


/*
 *****************************************************************************
 **                                  DOT                                    **
 *****************************************************************************
 */

/*
 * dot means inner product
 */

static void
BOOL_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
         void *NPY_UNUSED(ignore))
{
    Bool tmp = FALSE;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        if ((*((Bool *)ip1) != 0) && (*((Bool *)ip2) != 0)) {
            tmp = TRUE;
            break;
        }
    }
    *((Bool *)op) = tmp;
}

/**begin repeat
 *
 * #name = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, float, double, longdouble,
 *         datetime, timedelta#
 * #out = long, ulong, long, ulong, long, ulong, long, ulong,
 *        longlong, ulonglong, float, double, longdouble,
 *        datetime, timedelta#
 */
static void
@name@_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    @out@ tmp = (@out@)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (@out@)(*((@type@ *)ip1)) *
               (@out@)(*((@type@ *)ip2));
    }
    *((@type@ *)op) = (@type@) tmp;
}
/**end repeat**/


/**begin repeat
 *
 * #name = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = float, double, longdouble#
 */
static void @name@_dot(char *ip1, intp is1, char *ip2, intp is2,
                       char *op, intp n, void *NPY_UNUSED(ignore))
{
    @type@ tmpr = (@type@)0.0, tmpi=(@type@)0.0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmpr += ((@type@ *)ip1)[0] * ((@type@ *)ip2)[0]
                - ((@type@ *)ip1)[1] * ((@type@ *)ip2)[1];
        tmpi += ((@type@ *)ip1)[1] * ((@type@ *)ip2)[0]
                + ((@type@ *)ip1)[0] * ((@type@ *)ip2)[1];
    }
    ((@type@ *)op)[0] = tmpr; ((@type@ *)op)[1] = tmpi;
}

/**end repeat**/


/*
 *****************************************************************************
 **                                 FILL                                    **
 *****************************************************************************
 */

/**begin repeat
 *
 * #NAME = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #typ =  byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, float, double, longdouble,
 *         datetime, timedelta#
*/
static void
@NAME@_fill(@typ@ *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    @typ@ start = buffer[0];
    @typ@ delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}
/**end repeat**/

/**begin repeat
 *
 * #NAME = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #typ = cfloat, cdouble, clongdouble#
*/
static void
@NAME@_fill(@typ@ *buffer, intp length, void *NPY_UNUSED(ignore))
{
    intp i;
    @typ@ start;
    @typ@ delta;

    start.real = buffer->real;
    start.imag = buffer->imag;
    delta.real = buffer[1].real;
    delta.imag = buffer[1].imag;
    delta.real -= start.real;
    delta.imag -= start.imag;
    buffer += 2;
    for (i = 2; i < length; i++, buffer++) {
        buffer->real = start.real + i*delta.real;
        buffer->imag = start.imag + i*delta.imag;
    }
}
/**end repeat**/


/**begin repeat
 *
 * #NAME = BOOL, BYTE, UBYTE#
 * #typ = Bool, byte, ubyte#
 */
static void
@NAME@_fillwithscalar(@typ@ *buffer, intp length, @typ@ *value, void *NPY_UNUSED(ignored))
{
    memset(buffer, *value, length);
}
/**end repeat**/

/**begin repeat
 *
 * #NAME = SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG, ULONGLONG,
 *         FLOAT, DOUBLE, LONGDOUBLE, CFLOAT, CDOUBLE, CLONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #typ = short, ushort, int, uint, long, ulong, longlong, ulonglong,
 *        float, double, longdouble, cfloat, cdouble, clongdouble,
 *        datetime, timedelta#
 */
static void
@NAME@_fillwithscalar(@typ@ *buffer, intp length, @typ@ *value, void *NPY_UNUSED(ignored))
{
    intp i;
    @typ@ val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}
/**end repeat**/


/*
 *****************************************************************************
 **                               FASTCLIP                                  **
 *****************************************************************************
 */


/**begin repeat
 *
 * #name = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, float, double, longdouble,
 *         datetime, timedelta#
 */
static void
@name@_fastclip(@type@ *in, intp ni, @type@ *min, @type@ *max, @type@ *out)
{
    npy_intp i;
    @type@ max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
    }
    if (min != NULL) {
        min_val = *min;
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (in[i] < min_val) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (in[i] > max_val) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (in[i] < min_val) {
                out[i]   = min_val;
            }
            else if (in[i] > max_val) {
                out[i]   = max_val;
            }
        }
    }
}
/**end repeat**/

/**begin repeat
 *
 * #name = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = cfloat, cdouble, clongdouble#
 */
static void
@name@_fastclip(@type@ *in, intp ni, @type@ *min, @type@ *max, @type@ *out)
{
    npy_intp i;
    @type@ max_val, min_val;

    min_val = *min;
    max_val = *max;
    if (max != NULL) {
        max_val = *max;
    }
    if (min != NULL) {
        min_val = *min;
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i],min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i], min_val)) {
                out[i] = min_val;
            }
            else if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
}

/**end repeat**/



/*
 *****************************************************************************
 **                              FASTPUTMASK                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #name = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE, DATETIME, TIMEDELTA#
 * #type = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, float, double, longdouble,
 *         cfloat, cdouble, clongdouble, datetime, timedelta#
*/
static void
@name@_fastputmask(@type@ *in, Bool *mask, intp ni, @type@ *vals, intp nv)
{
    npy_intp i;
    @type@ s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}
/**end repeat**/

#define OBJECT_fastputmask NULL


/*
 *****************************************************************************
 **                                FASTTAKE                                 **
 *****************************************************************************
 */


/**begin repeat
 *
 * #name = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE, DATETIME, TIMEDELTA#
 * #type = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, float, double, longdouble,
 *         cfloat, cdouble, clongdouble, datetime, timedelta#
*/
static int
@name@_fasttake(@type@ *dest, @type@ *src, npy_intp *indarray,
                    npy_intp nindarray, npy_intp n_outer,
                    npy_intp m_middle, npy_intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    NpyErr_SetString(NpyExc_IndexError,
                                     "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}
/**end repeat**/

#define OBJECT_fasttake NULL


/*
 *****************************************************************************
 **                       SETUP FUNCTION POINTERS                           **
 *****************************************************************************
 */


#define _ALIGN(type) offsetof(struct {char c; type v;}, v)
/*
 * Disable harmless compiler warning "4116: unnamed type definition in
 * parentheses" which is caused by the _ALIGN macro.
 */
#if defined(_MSC_VER)
#pragma warning(disable:4116)
#endif


/**begin repeat
 *
 * #from = VOID, STRING, UNICODE#
 * #align = char, char, NpyArray_UCS4#
 * #NAME = Void, String, Unicode#
 * #endian = |, |, =#
*/
static NpyArray_ArrFuncs _Npy@NAME@_ArrFuncs = {
    (NpyArray_GetItemFunc*)@from@_getitem,
    (NpyArray_SetItemFunc*)@from@_setitem,
    (NpyArray_CopySwapNFunc*)@from@_copyswapn,
    (NpyArray_CopySwapFunc*)@from@_copyswap,
    (NpyArray_CompareFunc*)@from@_compare,
    (NpyArray_ArgFunc*)@from@_argmax,
    (NpyArray_DotFunc*)NULL,
    (NpyArray_ScanFunc*)@from@_scan,
    (NpyArray_FromStrFunc*)@from@_fromstr,
    (NpyArray_NonzeroFunc*)@from@_nonzero,
    (NpyArray_FillFunc*)NULL,
    (NpyArray_FillWithScalarFunc*)NULL,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (NpyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (NpyArray_FastClipFunc *)NULL,
    (NpyArray_FastPutmaskFunc *)NULL,
    (NpyArray_FastTakeFunc *)NULL,
    NULL, NULL, NULL, NULL,
    {
        (NpyArray_VectorUnaryFunc*)@from@_to_BOOL,
        (NpyArray_VectorUnaryFunc*)@from@_to_BYTE,
        (NpyArray_VectorUnaryFunc*)@from@_to_UBYTE,
        (NpyArray_VectorUnaryFunc*)@from@_to_SHORT,
        (NpyArray_VectorUnaryFunc*)@from@_to_USHORT,
        (NpyArray_VectorUnaryFunc*)@from@_to_INT,
        (NpyArray_VectorUnaryFunc*)@from@_to_UINT,
        (NpyArray_VectorUnaryFunc*)@from@_to_LONG,
        (NpyArray_VectorUnaryFunc*)@from@_to_ULONG,
        (NpyArray_VectorUnaryFunc*)@from@_to_LONGLONG,
        (NpyArray_VectorUnaryFunc*)@from@_to_ULONGLONG,
        (NpyArray_VectorUnaryFunc*)@from@_to_FLOAT,
        (NpyArray_VectorUnaryFunc*)@from@_to_DOUBLE,
        (NpyArray_VectorUnaryFunc*)@from@_to_LONGDOUBLE,
        (NpyArray_VectorUnaryFunc*)@from@_to_CFLOAT,
        (NpyArray_VectorUnaryFunc*)@from@_to_CDOUBLE,
        (NpyArray_VectorUnaryFunc*)@from@_to_CLONGDOUBLE,
        (NpyArray_VectorUnaryFunc*)@from@_to_DATETIME,
        (NpyArray_VectorUnaryFunc*)@from@_to_TIMEDELTA,
        (NpyArray_VectorUnaryFunc*)@from@_to_OBJECT,
        (NpyArray_VectorUnaryFunc*)@from@_to_STRING,
        (NpyArray_VectorUnaryFunc*)@from@_to_UNICODE,
        (NpyArray_VectorUnaryFunc*)@from@_to_VOID
    }
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT NpyArray_Descr @from@_Descr = {
    _NpyObject_HEAD_INIT(&NpyArrayDescr_Type)
    NPY_VALID_MAGIC,
    NpyArray_@from@LTR,
    NpyArray_@from@LTR,
    '@endian@',
    0,
    0,
    NpyArray_@from@,
    0,
    _ALIGN(@align@),
    NULL,
    NULL,
    NULL,
    &_Npy@NAME@_ArrFuncs,
    NULL,
};

/**end repeat**/


/**begin repeat
 *
 * #from = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE, OBJECT, DATETIME, TIMEDELTA#
 * #num = 1*14, 2*3, 1*3#
 * #fromtyp = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *            longlong, ulonglong, float, double, longdouble,
 *            float, double, longdouble, PyObject *, datetime, timedelta#
 * #NAME = Bool, Byte, UByte, Short, UShort, Int, UInt, Long, ULong,
 *         LongLong, ULongLong, Float, Double, LongDouble,
 *         CFloat, CDouble, CLongDouble, Object, Datetime, Timedelta#
 * #kind = GENBOOL, SIGNED, UNSIGNED, SIGNED, UNSIGNED, SIGNED, UNSIGNED, SIGNED, UNSIGNED,
 *         SIGNED, UNSIGNED, FLOATING, FLOATING, FLOATING,
 *         COMPLEX, COMPLEX, COMPLEX, OBJECT, DATETIME, TIMEDELTA#
 * #endian = |*3, =*14, |, =*2#
 * #isobject= 0*17,NPY_OBJECT_DTYPE_FLAGS,0*2#
 */
static NpyArray_ArrFuncs _Npy@NAME@_ArrFuncs = {
    (NpyArray_GetItemFunc*)@from@_getitem,
    (NpyArray_SetItemFunc*)@from@_setitem,
    (NpyArray_CopySwapNFunc*)@from@_copyswapn,
    (NpyArray_CopySwapFunc*)@from@_copyswap,
    (NpyArray_CompareFunc*)@from@_compare,
    (NpyArray_ArgFunc*)@from@_argmax,
    (NpyArray_DotFunc*)@from@_dot,
    (NpyArray_ScanFunc*)@from@_scan,
    (NpyArray_FromStrFunc*)@from@_fromstr,
    (NpyArray_NonzeroFunc*)@from@_nonzero,
    (NpyArray_FillFunc*)@from@_fill,
    (NpyArray_FillWithScalarFunc*)@from@_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (NpyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (NpyArray_FastClipFunc*)@from@_fastclip,
    (NpyArray_FastPutmaskFunc*)@from@_fastputmask,
    (NpyArray_FastTakeFunc*)@from@_fasttake,
    NULL, NULL, NULL, NULL,
    {
        (NpyArray_VectorUnaryFunc*)@from@_to_BOOL,
        (NpyArray_VectorUnaryFunc*)@from@_to_BYTE,
        (NpyArray_VectorUnaryFunc*)@from@_to_UBYTE,
        (NpyArray_VectorUnaryFunc*)@from@_to_SHORT,
        (NpyArray_VectorUnaryFunc*)@from@_to_USHORT,
        (NpyArray_VectorUnaryFunc*)@from@_to_INT,
        (NpyArray_VectorUnaryFunc*)@from@_to_UINT,
        (NpyArray_VectorUnaryFunc*)@from@_to_LONG,
        (NpyArray_VectorUnaryFunc*)@from@_to_ULONG,
        (NpyArray_VectorUnaryFunc*)@from@_to_LONGLONG,
        (NpyArray_VectorUnaryFunc*)@from@_to_ULONGLONG,
        (NpyArray_VectorUnaryFunc*)@from@_to_FLOAT,
        (NpyArray_VectorUnaryFunc*)@from@_to_DOUBLE,
        (NpyArray_VectorUnaryFunc*)@from@_to_LONGDOUBLE,
        (NpyArray_VectorUnaryFunc*)@from@_to_CFLOAT,
        (NpyArray_VectorUnaryFunc*)@from@_to_CDOUBLE,
        (NpyArray_VectorUnaryFunc*)@from@_to_CLONGDOUBLE,
        (NpyArray_VectorUnaryFunc*)@from@_to_DATETIME,
        (NpyArray_VectorUnaryFunc*)@from@_to_TIMEDELTA,
        (NpyArray_VectorUnaryFunc*)@from@_to_OBJECT,
        (NpyArray_VectorUnaryFunc*)@from@_to_STRING,
        (NpyArray_VectorUnaryFunc*)@from@_to_UNICODE,
        (NpyArray_VectorUnaryFunc*)@from@_to_VOID
    }
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT NpyArray_Descr @from@_Descr = {
    _NpyObject_HEAD_INIT(&NpyArrayDescr_Type)
    NPY_VALID_MAGIC,
    NpyArray_@kind@LTR,
    NpyArray_@from@LTR,
    '@endian@',
    0,
    @isobject@,
    NpyArray_@from@,
    @num@*sizeof(@fromtyp@),
    _ALIGN(@fromtyp@),
    NULL,
    NULL,
    NULL,
    &_Npy@NAME@_ArrFuncs,
    NULL,
};

/**end repeat**/

static void
_init_datetime_descr(NpyArray_Descr *descr)
{
    NpyArray_DateTimeInfo *dt_data;
    
    dt_data = NpyArray_malloc(sizeof(NpyArray_DateTimeInfo));
    dt_data->base = NPY_FR_us;
    dt_data->num = 1;
    dt_data->den = 1;
    dt_data->events = 1;
    
    /* FIXME
     * There is no error check here and no way to indicate an error
     * until the metadata turns up NULL.
     */
    descr->dtinfo = dt_data;    
}




#define _MAX_LETTER 128
char _npy_letter_to_num[_MAX_LETTER];

static NpyArray_Descr *_builtin_descrs[] = {
    &BOOL_Descr,
    &BYTE_Descr,
    &UBYTE_Descr,
    &SHORT_Descr,
    &USHORT_Descr,
    &INT_Descr,
    &UINT_Descr,
    &LONG_Descr,
    &ULONG_Descr,
    &LONGLONG_Descr,
    &ULONGLONG_Descr,
    &FLOAT_Descr,
    &DOUBLE_Descr,
    &LONGDOUBLE_Descr,
    &CFLOAT_Descr,
    &CDOUBLE_Descr,
    &CLONGDOUBLE_Descr,
    &DATETIME_Descr,
    &TIMEDELTA_Descr,
    &OBJECT_Descr,
    &STRING_Descr,
    &UNICODE_Descr,
    &VOID_Descr,
};



/* The interface layer needs to be given the opportunity to provide a wrapper
 for each built-in type descr before it ever gets returned to the interface
 layer.  This should only ever be performed once. */
static int _builtin_descrs_wrapped = NPY_FALSE;

static void _init_builtin_descr_wrappers()
{
    int type;
    
    /* TODO: Need thread locking here. */
    if (NPY_FALSE == _builtin_descrs_wrapped) {
        _builtin_descrs_wrapped = NPY_TRUE;
        
        for (type=0; type < NPY_NTYPES; type++) {
            assert( NULL == Npy_INTERFACE(_builtin_descrs[type]) ); /* Should only ever be called once. */
            NpyInterface_DescrNewFromType(type, _builtin_descrs[type], &_builtin_descrs[type]->nob_interface);
        }
    }
}



/* Get the NpyArray_Descr structure for a type.
 */
NpyArray_Descr *
NpyArray_DescrFromType(int type)
{
    NpyArray_Descr *ret = NULL;

    if (NPY_FALSE == _builtin_descrs_wrapped) {
        _init_builtin_descr_wrappers();        
    }
    
    if (type < NPY_NTYPES) {
        ret = _builtin_descrs[type];
    }
    else if (type == NPY_NOTYPE) {
        /*
         * This needs to not raise an error so
         * that NpyArray_DescrFromType(NpyArray_NOTYPE)
         * works for backwards-compatible C-API
         */
        return NULL;
    }
    else if ((type == NPY_CHAR) || (type == NPY_CHARLTR)) {
        ret = NpyArray_DescrNew(_builtin_descrs[NPY_STRING]);
        if (ret == NULL) {
            return NULL;
        }
        ret->elsize = 1;
        ret->type = NPY_CHARLTR;
        return ret;
    }
    else if (NpyTypeNum_ISUSERDEF(type)) {
        ret = NpyArray_UserDescrFromTypeNum(type);
    }
    else {
        int num = NPY_NTYPES;
        if (type < _MAX_LETTER) {
            num = (int) _npy_letter_to_num[type];
        }
        if (num >= NPY_NTYPES) {
            ret = NULL;
        }
        else {
            ret = _builtin_descrs[num];
        }
    }
    if (ret == NULL) {
        NpyErr_SetString(NpyExc_ValueError,
                "Invalid data-type for array");
    }
    else {
        _Npy_INCREF(ret);
    }

    /* Make sure dtype metadata is initialized for DATETIME */
    if (NpyTypeNum_ISDATETIME(type)) {
        if (ret->dtinfo == NULL) {
            _init_datetime_descr(ret);
        }
    }

    return ret;
}


#undef _MAX_LETTER

