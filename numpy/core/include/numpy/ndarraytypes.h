#ifndef _NDARRAYTYPES_H_
#define _NDARRAYTYPES_H_

#include <assert.h>
#include <Python.h>

/* This is auto-generated by the installer */
#include "numpyconfig.h"

#include "npy_api.h"
#include "npy_utils.h"
#include "npy_arrayobject.h"



#define NPY_NO_EXPORT NPY_VISIBILITY_HIDDEN


/* Only use thread if configured in config and python supports it */
#if defined WITH_THREAD && !NPY_NO_SMP
        #define NPY_ALLOW_THREADS 1
#else
        #define NPY_ALLOW_THREADS 0
#endif



/* Used for Converter Functions "O&" code in ParseTuple */
#define NPY_FAIL 0
#define NPY_SUCCEED 1

/*
 * Binary compatibility version number.  This number is increased
 * whenever the C-API is changed such that binary compatibility is
 * broken, i.e. whenever a recompile of extension modules is needed.
 */
#define NPY_VERSION NPY_ABI_VERSION

/*
 * Minor API version.  This number is increased whenever a change is
 * made to the C-API -- whether it breaks binary compatibility or not.
 * Some changes, such as adding a function pointer to the end of the
 * function table, can be made without breaking binary compatibility.
 * In this case, only the NPY_FEATURE_VERSION (*not* NPY_VERSION)
 * would be increased.  Whenever binary compatibility is broken, both
 * NPY_VERSION and NPY_FEATURE_VERSION should be increased.
 */
#define NPY_FEATURE_VERSION NPY_API_VERSION

/* basetype array priority */
#define NPY_PRIORITY 0.0

/* default subtype priority */
#define NPY_SUBTYPE_PRIORITY 1.0

/* default scalar priority */
#define NPY_SCALAR_PRIORITY -1000000.0

typedef NpyArray_CopySwapFunc PyArray_CopySwapFunc;
typedef NpyArray_CopySwapNFunc PyArray_CopySwapNFunc;
typedef NpyArray_ArgFunc PyArray_ArgFunc;
typedef NpyArray_VectorUnaryFunc PyArray_VectorUnaryFunc;
typedef NpyArray_FastTakeFunc PyArray_FastTakeFunc;
typedef NpyArray_FastPutmaskFunc PyArray_FastPutmaskFunc;
typedef NpyArray_SortFunc PyArray_SortFunc;
typedef NpyArray_ArgSortFunc PyArray_ArgSortFunc;
typedef NpyArray_CompareFunc PyArray_CompareFunc;
typedef struct NpyArray_CastFuncsItem PyArray_CastFuncsItem;
typedef NpyArray_GetItemFunc PyArray_GetItemFunc;
typedef NpyArray_SetItemFunc PyArray_SetItemFunc;
typedef NpyArray_ScanFunc PyArray_ScanFunc;
typedef NpyArray_FromStrFunc PyArray_FromStrFunc;
typedef NpyArray_NonzeroFunc PyArray_NonzeroFunc;
typedef NpyArray_FillFunc PyArray_FillFunc;
typedef NpyArray_FillWithScalarFunc PyArray_FillWithScalarFunc;
typedef NpyArray_ScalarKindFunc PyArray_ScalarKindFunc;
typedef NpyArray_FastClipFunc PyArray_FastClipFunc;
typedef NpyArray_DotFunc PyArray_DotFunc;


typedef npy_intp intp;



/*
 * We need to match npy_intp to a signed integer of the same size as a
 * pointer variable. npy_uintp to the equivalent unsigned integer
 */

typedef struct _PyArray_Descr PyArray_Descr;
typedef struct NpyArray_ArrFuncs PyArray_ArrFuncs;


#ifdef constchar
#undef constchar
#endif

#if (PY_VERSION_HEX < 0x02050000)
  #ifndef PY_SSIZE_T_MIN
    typedef int Py_ssize_t;
    #define PY_SSIZE_T_MAX INT_MAX
    #define PY_SSIZE_T_MIN INT_MIN
  #endif
#define NPY_SSIZE_T_PYFMT "i"
#undef PyIndex_Check
#define constchar const char
#define PyIndex_Check(op) 0
#else
#define NPY_SSIZE_T_PYFMT "n"
#define constchar char
#endif


/*
 * We can only use C99 formats for npy_int_p if it is the same as
 * intp_t, hence the condition on HAVE_UNITPTR_T
 */
#if NPY_USE_C99_FORMATS == 1 \
        && (defined HAVE_UINTPTR_T) \
        && (defined HAVE_INTTYPES_H)
    #include <inttypes.h>
    #undef NPY_INTP_FMT
    #define NPY_INTP_FMT PRIdPTR
#endif

#define NPY_ERR(str) fprintf(stderr, #str); fflush(stderr);
#define NPY_ERR2(str) fprintf(stderr, str); fflush(stderr);

#define NPY_STRINGIFY(x) #x
#define NPY_TOSTRING(x) NPY_STRINGIFY(x)

  /*
   * Macros to define how array, and dimension/strides data is
   * allocated.
   */

  /* Data buffer */
#define PyDataMem_NEW(size) ((char *)malloc(size))
#define PyDataMem_FREE(ptr)  free(ptr)
#define PyDataMem_RENEW(ptr,size) ((char *)realloc(ptr,size))

#define NPY_USE_PYMEM 0     /* TODO: BAAAD things happen if we use PyMem because core can't free it. */

#if NPY_USE_PYMEM == 1
#define PyArray_malloc PyMem_Malloc
#define PyArray_free PyMem_Free
#define PyArray_realloc PyMem_Realloc
#else
#define PyArray_malloc malloc
#define PyArray_free free
#define PyArray_realloc realloc
#endif

/* Dimensions and strides */
#define PyDimMem_NEW(size)                                         \
    ((npy_intp *)PyArray_malloc(size*sizeof(npy_intp)))

#define PyDimMem_FREE(ptr) PyArray_free(ptr)

#define PyDimMem_RENEW(ptr,size)                                   \
        ((npy_intp *)PyArray_realloc(ptr,size*sizeof(npy_intp)))

/* forward declaration */
struct _PyArray_Descr;



#define PyDataType_FLAGCHK(dtype, flag) NpyDataType_FLAGCHK(dtype->descr, flag)

#define PyDataType_REFCHK(dtype)  NpyDataType_REFCHK(dtype->descr) 


struct NpyDict_struct;     /* TODO: From numpy_api.h, needed until PyArray_Descr is split into
                              CPython and core parts */


struct _PyArray_Descr {
        PyObject_HEAD
        int magic_number;       /* Initialized to NPY_VALID_MAGIC initialization and 
                                   NPY_INVALID_MAGIC on dealloc */
        PyTypeObject *typeobj;  /*
                                 * the type object representing an
                                 * instance of this type -- should not
                                 * be two type_numbers with the same type
                                 * object.
                                 */
    
        struct NpyArray_Descr *descr;   /* Core object */
};

NPY_NO_EXPORT PyObject *
PyArrayDescr_GetNames(PyArray_Descr *self);
NPY_NO_EXPORT PyObject *
PyArrayDescr_GetFields(PyArray_Descr *self);


/*
 * The main array object structure. It is recommended to use the macros
 * defined below (PyArray_DATA and friends) access fields here, instead
 * of the members themselves.
 */

typedef struct PyArrayObject {
    PyObject_HEAD
    int magic_number;
    struct NpyArray *array;
    PyObject *weakreflist;  /* For weakreferences */
} PyArrayObject;

#define NPY_AO PyArrayObject

#define fortran fortran_        /* For some compilers */

/* Array Flags Object */
typedef struct PyArrayFlagsObject {
        PyObject_HEAD
        PyObject *arr;
        int flags;
} PyArrayFlagsObject;

/* Mirrors buffer object to ptr */

typedef struct {
        PyObject_HEAD
        PyObject *base;
        void *ptr;
        npy_intp len;
        int flags;
} PyArray_Chunk;



typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);


#define PyArray_MAX(a,b) (((a)>(b))?(a):(b))
#define PyArray_MIN(a,b) (((a)<(b))?(a):(b))
#define PyArray_CLT(p,q) ((((p).real==(q).real) ? ((p).imag < (q).imag) : \
                               ((p).real < (q).real)))
#define PyArray_CGT(p,q) ((((p).real==(q).real) ? ((p).imag > (q).imag) : \
                               ((p).real > (q).real)))
#define PyArray_CLE(p,q) ((((p).real==(q).real) ? ((p).imag <= (q).imag) : \
                               ((p).real <= (q).real)))
#define PyArray_CGE(p,q) ((((p).real==(q).real) ? ((p).imag >= (q).imag) : \
                               ((p).real >= (q).real)))
#define PyArray_CEQ(p,q) (((p).real==(q).real) && ((p).imag == (q).imag))
#define PyArray_CNE(p,q) (((p).real!=(q).real) || ((p).imag != (q).imag))

/*
 * C API: consists of Macros and functions.  The MACROS are defined
 * here.
 */

#define PyArray_ARRAY(m) ((m) ? assert(PyArray_Check(m)),(((PyArrayObject *)(m))->array) : NULL)
#define PyArray_LARRAY(m) (((PyArrayObject *)(m))->array)

#define PAA(m) PyArray_LARRAY(m)

#define PyArray_CHKFLAGS(m, FLAGS) NpyArray_CHKFLAGS(PAA(m), FLAGS)

#define PyArray_ISCONTIGUOUS(m) NpyArray_ISCONTIGUOUS(PAA(m))
#define PyArray_ISWRITEABLE(m) NpyArray_ISWRITEABLE(PAA(m))
#define PyArray_ISALIGNED(m) NpyArray_ISALIGNED(PAA(m))



/* 
 * Descriptor definitions
 */

struct NpyArray_Dims;

typedef struct NpyArray_Dims PyArray_Dims;



/*****************************
 * Basic iterator object
 *****************************/

/* FWD declaration */
struct NpyArrayIterObject;

typedef struct PyArrayIterObject_tag {
        PyObject_HEAD
        int  magic_number;       /* Initialized to NPY_VALID_MAGIC initialization and NPY_INVALID_MAGIC on dealloc */
        struct NpyArrayIterObject* iter;
} PyArrayIterObject;


/* Iterator API */
#define PyArrayIter_Check(op) PyObject_TypeCheck(op, &PyArrayIter_Type)

#define _PyAIT(it) ((PyArrayIterObject *)(it))
#define _NpyAIT(it) _PyAIT(it)->iter
#define PyArray_ITER_RESET(it) \
    assert(PyArrayIter_Check(it)); \
    NpyArray_ITER_RESET(_NpyAIT(it))
#define PyArray_ITER_NEXT(it) \
    assert(PyArrayIter_Check(it)); \
    NpyArray_ITER_NEXT(_NpyAIT(it))
#define PyArray_ITER_GOTO(it, destination) \
    assert(PyArrayIter_Check(it)); \
    NpyArray_ITER_GOTO(_NpyAIT(it), destination)
#define PyArray_ITER_GOTO1D(it, ind) \
    assert(PyArrayIter_Check(it)); \
    NpyArray_ITER_GOTO1D(_NpyAIT(it), ind)
#define PyArray_ITER_DATA(it) (assert(PyArrayIter_Check(it)), NpyArray_ITER_DATA(_NpyAIT(it)))

#define PyArray_ITER_NOTDONE(it) (assert(PyArrayIter_Check(it)), NpyArray_ITER_NOTDONE(_NpyAIT(it)))


struct NpyArrayMultiIterObject;

typedef struct {
    PyObject_HEAD
    int               magic_number;       /* Initialized to NPY_VALID_MAGIC initialization and NPY_INVALID_MAGIC on dealloc */
    struct NpyArrayMultiIterObject* iter;
} PyArrayMultiIterObject;

#define _PyMIT(m) ((PyArrayMultiIterObject *)(m))
#define _NpyMIT(m) _PyMIT(m)->iter
#define PyArray_MultiIter_RESET(multi) \
    NpyArray_MultiIter_RESET(_NpyMIT(multi))
#define PyArray_MultiIter_NEXT(multi) \
    NpyArray_MultiIter_NEXT(_NpyMIT(multi))
#define PyArray_MultiIter_GOTO(multi, dest) \
    NpyArray_MultiIter_GOTO(_NpyMIT(multi), dest)
#define PyArray_MultiIter_GOTO1D(multi, ind) \
    NpyArray_MultiIter_GOTO1D(_NpyMIT(multi), ind)
#define PyArray_MultiIter_DATA(multi, i)                \
    NpyArray_MultiIter_DATA(_NpyMIT(multi), i)
#define PyArray_MultiIter_NEXTi(multi, i)               \
    NpyArray_MultiIter_NEXTi(_NpyMIT(multi), i)

#define PyArray_MultiIter_NOTDONE(multi)                \
    NpyArray_MultiIter_NOTDONE(_NpyMIT(multi))

/* Store the information needed for fancy-indexing over an array */
struct NpyArrayMapIterObject;
struct NpyArrayNeighborhoodIterObject;

typedef struct {
        PyObject_HEAD
        /*
         * Multi-iterator portion --- needs to be present in this
         * order to work with PyArray_Broadcast
         */
        int  magic_number;            /* Initialized to NPY_VALID_MAGIC initialization and NPY_INVALID_MAGIC on dealloc */
        struct NpyArrayMapIterObject* iter;
        PyObject* indexobj;
} PyArrayMapIterObject;

typedef struct {
    PyObject_HEAD
    int  magic_number;       /* Initialized to NPY_VALID_MAGIC initialization and NPY_INVALID_MAGIC on dealloc */
    struct NpyArrayNeighborhoodIterObject* iter;
} PyArrayNeighborhoodIterObject;

/*
 * Neighborhood iterator API
 */

#define _NPY_INCLUDE_NEIGHBORHOOD_IMP
#include "npy_neighbor_imp.h"
#undef _NPY_INCLUDE_NEIGHBORHOOD_IMP

#define PyArrayNeighborhoodIter_Reset(iter) \
    NpyArrayNeighborhoodIter_Reset((iter)->iter)

#define PyArrayNeighborhoodIter_Next(iter) \
    NpyArrayNeighborhoodIter_Next((iter)->iter)

#define PyArray_DEFAULT NPY_DEFAULT_TYPE


/* Useful macros for getting PyObject back from interface pointer returned from the core. */
#define PyArray_Descr_WRAP(ptr) \
    ((assert( (ptr) != NULL && PyArray_DescrCheck((PyObject *)Npy_INTERFACE(ptr)))), \
    (PyArray_Descr *)Npy_INTERFACE(ptr))

#define PyArray_WRAP(ptr) \
    ((assert( (ptr) != NULL && PyArray_Check((PyObject *)Npy_INTERFACE(ptr)))), \
    (PyArrayObject *)Npy_INTERFACE(ptr))


/*
 * All sorts of useful ways to look into a PyArrayObject.  These are
 * the recommended over casting to PyArrayObject and accessing the
 * members directly.
 */

#define PyArray_NDIM(obj) NpyArray_NDIM(PAA(obj))
#define PyArray_ISONESEGMENT(m) NpyArray_ISONESEGMENT(PAA(m))
#define PyArray_ISFORTRAN(m) NpyArray_ISFORTRAN(PAA(m))
#define PyArray_FORTRAN_IF(m) NpyArray_FORTRAN_IF(PAA(m))
#define FORTRAN_IF PyArray_FORTRAN_IF
#define PyArray_DATA(obj) NpyArray_DATA(PAA(obj))
#define PyArray_BYTES(obj) NpyArray_BYTES(PAA(obj))
#define PyArray_DIMS(obj) NpyArray_DIMS(PAA(obj))
#define PyArray_STRIDES(obj) NpyArray_STRIDES(PAA(obj))
#define PyArray_DIM(obj,n) NpyArray_DIM(PAA(obj),n)
#define PyArray_STRIDE(obj,n) NpyArray_STRIDE(PAA(obj),n)
#define PyArray_DESCR(obj) NpyArray_DESCR(PAA(obj))
#define PyArray_FLAGS(obj) NpyArray_FLAGS(PAA(obj))
#define PyArray_ITEMSIZE(obj) NpyArray_ITEMSIZE(PAA(obj))
#define PyArray_TYPE(obj) NpyArray_TYPE(PAA(obj))
#define PyArray_BASE_ARRAY(obj) NpyArray_BASE_ARRAY(PAA(obj))
#define PyArray_BASE(obj) NpyArray_BASE(PAA(obj))

#define PyArray_GETITEM(obj, itemptr)                               \
    (PAA(obj))->descr->f->getitem((char *)(itemptr),                \
                                  (PyArrayObject *) (PAA(obj)))

#define PyArray_SETITEM(obj, itemptr, v)                            \
    (PAA(obj))->descr->f->setitem((PyObject *)(v),                  \
                                  (char *)(itemptr),                \
                                  (PAA(obj)))

#define PyDataType_BYTEORDER(obj) ((obj)->descr->byteorder)
#define PyDataType_ELSIZE(obj) ((obj)->descr->elsize)
#define PyDataType_TYPE_NUM(obj) ((obj)->descr->type_num)

/* WARNING: These two functions return an object with a new reference that
   must be released by the caller.  This is because the core library stores
   the data in a different format now so there is no refeference to borrow. */
#define PyDataType_FIELDS(obj) PyArrayDescr_GetFields(obj)
#define PyDataType_NAMES(obj) PyArrayDescr_GetNames(obj)


#define _PyADT(obj) (assert(NULL != obj && \
      PyArray_DescrCheck(obj)),((PyArray_Descr *)(obj))->descr->type_num)
#define PyDataType_ISBOOL(obj) NpyTypeNum_ISBOOL(_PyADT(obj))
#define PyDataType_ISUNSIGNED(obj) NpyTypeNum_ISUNSIGNED(_PyADT(obj))
#define PyDataType_ISSIGNED(obj) NpyTypeNum_ISSIGNED(_PyADT(obj))
#define PyDataType_ISINTEGER(obj) NpyTypeNum_ISINTEGER(_PyADT(obj))
#define PyDataType_ISFLOAT(obj) NpyTypeNum_ISFLOAT(_PyADT(obj))
#define PyDataType_ISNUMBER(obj) NpyTypeNum_ISNUMBER(_PyADT(obj))
#define PyDataType_ISSTRING(obj) NpyTypeNum_ISSTRING(_PyADT(obj))
#define PyDataType_ISCOMPLEX(obj) NpyTypeNum_ISCOMPLEX(_PyADT(obj))
#define PyDataType_ISPYTHON(obj) NpyTypeNum_ISPYTHON(_PyADT(obj))
#define PyDataType_ISFLEXIBLE(obj) NpyTypeNum_ISFLEXIBLE(_PyADT(obj))
#define PyDataType_ISDATETIME(obj) NpyTypeNum_ISDATETIME(_PyADT(obj))
#define PyDataType_ISUSERDEF(obj) NpyTypeNum_ISUSERDEF(_PyADT(obj))
#define PyDataType_ISEXTENDED(obj) NpyTypeNum_ISEXTENDED(_PyADT(obj))
#define PyDataType_ISOBJECT(obj) NpyTypeNum_ISOBJECT(_PyADT(obj))
#define PyDataType_HASFIELDS(obj) ((obj)->descr->names != NULL)

#define PyArray_ISBOOL(obj) NpyTypeNum_ISBOOL(PyArray_TYPE(obj))
#define PyArray_ISUNSIGNED(obj) NpyTypeNum_ISUNSIGNED(PyArray_TYPE(obj))
#define PyArray_ISSIGNED(obj) NpyTypeNum_ISSIGNED(PyArray_TYPE(obj))
#define PyArray_ISINTEGER(obj) NpyTypeNum_ISINTEGER(PyArray_TYPE(obj))
#define PyArray_ISFLOAT(obj) NpyTypeNum_ISFLOAT(PyArray_TYPE(obj))
#define PyArray_ISNUMBER(obj) NpyTypeNum_ISNUMBER(PyArray_TYPE(obj))
#define PyArray_ISSTRING(obj) NpyTypeNum_ISSTRING(PyArray_TYPE(obj))
#define PyArray_ISCOMPLEX(obj) NpyTypeNum_ISCOMPLEX(PyArray_TYPE(obj))
#define PyArray_ISPYTHON(obj) NpyTypeNum_ISPYTHON(PyArray_TYPE(obj))
#define PyArray_ISFLEXIBLE(obj) NpyTypeNum_ISFLEXIBLE(PyArray_TYPE(obj))
#define PyArray_ISDATETIME(obj) NpyTypeNum_ISDATETIME(PyArray_TYPE(obj))
#define PyArray_ISUSERDEF(obj) NpyTypeNum_ISUSERDEF(PyArray_TYPE(obj))
#define PyArray_ISEXTENDED(obj) NpyTypeNum_ISEXTENDED(PyArray_TYPE(obj))
#define PyArray_ISOBJECT(obj) NpyTypeNum_ISOBJECT(PyArray_TYPE(obj))
#define PyArray_HASFIELDS(obj) NpyDataType_HASFIELDS(PyArray_DESCR(obj))

    /*
     * FIXME: This should check for a flag on the data-type that
     * states whether or not it is variable length.  Because the
     * ISFLEXIBLE check is hard-coded to the built-in data-types.
     */
#define PyArray_ISVARIABLE(obj) NpyArray_ISVARIABLE(PAA(obj))

#define PyArray_SAFEALIGNEDCOPY(obj) NpyArray_SAFEALIGNEDCOPY(PAA(obj))


#define PyArray_ISNOTSWAPPED(m) NpyArray_ISNOTSWAPPED(PAA(m))
#define PyArray_ISBYTESWAPPED(m) NpyArray_ISBYTESWAPPED(PAA(m))

#define PyArray_FLAGSWAP(m, flags) NpyArray_FLAGSWAP(PAA(m), flags)

#define PyArray_ISCARRAY(m) NpyArray_ISCARRAY(PAA(m))
#define PyArray_ISCARRAY_RO(m) NpyArray_ISCARRAY_RO(PAA(m))
#define PyArray_ISFARRAY(m) NpyArray_ISFARRAY(PAA(m))
#define PyArray_ISFARRAY_RO(m) NpyArray_ISFARRAY_RO(PAA(m))
#define PyArray_ISBEHAVED(m) NpyArray_ISBEHAVED(PAA(m))
#define PyArray_ISBEHAVED_RO(m) NpyArray_ISBEHAVED_RO(PAA(m))


#define PyDataType_ISNOTSWAPPED(d) NpyArray_ISNBO(((PyArray_Descr *)(d))->byteorder)
#define PyDataType_ISBYTESWAPPED(d) (!PyDataType_ISNOTSWAPPED(d))


/*
 * This is the form of the struct that's returned pointed by the
 * PyCObject attribute of an array __array_struct__. See
 * http://numpy.scipy.org/array_interface.shtml for the full
 * documentation.
 */
typedef struct {
    int two;              /*
                           * contains the integer 2 as a sanity
                           * check
                           */

    int nd;               /* number of dimensions */

    char typekind;        /*
                           * kind in array --- character code of
                           * typestr
                           */

    int itemsize;         /* size of each element */

    int flags;            /*
                           * how should be data interpreted. Valid
                           * flags are CONTIGUOUS (1), FORTRAN (2),
                           * ALIGNED (0x100), NOTSWAPPED (0x200), and
                           * WRITEABLE (0x400).  ARR_HAS_DESCR (0x800)
                           * states that arrdescr field is present in
                           * structure
                           */

    npy_intp *shape;       /*
                            * A length-nd array of shape
                            * information
                            */

    npy_intp *strides;    /* A length-nd array of stride information */

    void *data;           /* A pointer to the first element of the array */

    PyObject *descr;      /*
                           * A list of fields or NULL (ignored if flags
                           * does not have ARR_HAS_DESCR flag set)
                           */
} PyArrayInterface;

#endif /* _NDARRAYTYPES_H_ */
